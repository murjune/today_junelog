참고 블로긔 https://velog.io/@choonghee-lee/%EB%B2%88%EC%97%AD-Array-vs.-List-vs.-Python-List  


1. Array에 대해 알아보기 전에 메모리 관점에 대해 알아 본 후
2. Array vs Lists vs 파이썬 Lists에 대해 알아보자.  

# 메모리
1. volatile(휘발성) 메모리
2. non- volatile(비휘발성) 메모리  

non- volatile 메모리는 하드 드라이브와 같은 것인데, 컴퓨터를 껏다 키더라도 유지되는 데이터를 뜻한다.  

반면, volatile 메모리는 RAM 메모리와 같은 것인데, 컴퓨터를 껏다 키면 모든 데이터가 지워진다.  

프로그램이 돌아가고, 변수 생성 할때와 같은 것들이 모두 RAM에 저장된다.  (random access memory)

데이터를 읽는 속도: RAM > 하드드라이브 (데이터 접속을 랜덤하게 할 수 있기 때문 )
```
RAM을 박스들의 그룹이라고 생각해보자. (각 박스들은 데이터를 보관할 수 있고, 그 박스들의 이름을 memory address라 한다.)

예를 들어, 프로그램이 RAM 메모리에게 "memory address 2"를 요구한다면, RAM이 바로 빠르게 접속할 수 있는 것이다. (랜덤하게 접속이 가능하니까! )
즉, memory address0 -> memory address1 ->memory address2 순차적으로 가는게 아니라 바로 2로 갈 수 있다.


```
# 메모리 관점에서의 Array

배열을 만들 때, 컴퓨터에게 이 배열의 길이를 알려주어야 한다.  

ex) (박스 = 아이템)
    4개의 박스 크기의 배열을 만드려면(박스의 크기는 같다), 메모리 안에서 박스들이 나란히 위치할 수 있도록, 그 공간을 미리 예약/할당해 주어야 한다.  
    그렇다면, 컴퓨터는 이 배열이 얼마나 긴지, 어디서 시작하는지 알 수 있다. 
``` C

int numArr[4];    // 크기가 1인 배열. 요소가 1개
```
```
Python, JS는 사용자가 배열 길이를 설정해주지 않아도, 언어 자체가 직접 핸들링해주기 때문에 따로 배열의 길이를 지정해 줄 필요가 없다.  
대신 그 대가로 직접 핸들링을 해주는 C와 비교할 때 프로그램 속도가 느리다는 단점이 있다.

```
정리  
```
1. Array는 아이템들의 모임이다.(박스(메모리) 안에 아이템(데이터)이 있고, 박스의 이름은 memory address)
2. 아이템들은 순서가 있다.(= 배열의 아이템들은 메모리 상에서 이어져서 배치된다는 것이다.)
3. Array의 모든 아이템들이 똑같은 사이즈를 가진다.(모든 박스의 크기는 같다)
```

# Lists
리스트는 Array와 달리 아이템들의 메모리 주소가 연속적일 수도 있고, 아닐 수도 있다.  

ex) 대표적으로 하나의 아이템이 다음 아이템을 포인팅하는 Linked List가 있다. 
하지만 각 아이템들은 메모리 상에서 모두 흩어져 있을 수도 있다.(LinkedList 의 아이템들은, memory 어딘가에 저장되기 때문) 

이 경우에는 첫번째 아이템의 주소를 알더라도,  다음 아이템의 메모리 주소를 간단히 계산할 수 없다는 것을 의미한다. 
결국, 리스트는 배열처럼 아이템에 직접 접근하기 위해 인덱스를 사용할 수 없다는 뜻이기도 하다.  
```
LinkedList 는 Sequential Access 를 지원한다. (Array는 RAM)
어떤 아이템에 접근할 때, 처음 부터 순차적으로 탐색해야 한다.(Array는 주소에 의하여 데이터를 액세스)
따라서, 특정 아이템에 접근할 때의 시간 복잡도는 O(N)이다. (Array- O(1))
```
# 파이썬 Lists
위에서 리스트는 인덱스를 가지지 않는다고 말하였다. 그렇다면 파이썬 리스트는 왜 인덱스를 가질까?  

보통, 컴퓨터 공학에서 리스트는 위에서 말한 리스트를 의미하지만, 파이썬에서는 리스트라는 용어를 다르게 사용한다.  
파이썬의 리스트는 배열처럼 구현이 되어있어, 파이썬에서는 기본 자료형인 리스트가 배열의 역할을 포함한다.
```
파이썬 리스트의 아이템들은 배열과 동일하게 메모리 상의 연속적인 위치에 배치되며, 인덱스를 사용하여 접근이 가능하다.  
또한, 위에서 서술했던 것처럼 C의 배열과 다르게 배열의 길이를 지정해주지 않아도 된다.
```  
``` python
lst1 = [0] * 100
# 0으로 초기화 되어있는 리스트를 선언
lst2 = [False] * 100
# bool형, False로 초기화 되어있는 리스트 선언
lst3 = ['s','t','u','d','y']
# str형, 문자열을 가지고 있는 리스트의 모슴
lst4 = []
# 비어있는 리스트 선언

lst5 = [1,2,3,4]

lst5[0] # 0번째 인덱스에 위치하는 아이템: 1
# 개수는 사용자가 원하는 만큼 설정 가능!
# 선언 이후에도 수정이 가능합니다.
```
파이썬의 리스트의 특징을 좀더 살펴보면, 리스트에 아이템을 제거하는 pop과 리스트에 아이템을 추가하느 append 메소드를 지원한다.  
따라서, 이런 특징을 이용해서 파이썬 리스트를 stack처럼 활용할 수 있는 것이다.
``` python
stack = []

stack.append(1) # [1]
stack.pop() # []
```
# Array의 opearation
파이썬 코드로 예시를 들도록 하겠습니다 ㅎ ㅎ
## 1. Reading

Array는 0부터 인덱싱하고, 위치만 알면 배열의 데이터에 접속이 가능하다. (컴퓨터는 0부터 숫자를 세기 때문에).  

아래 파이썬 소스코드에 배열을 어떻게 읽는지 예시로 나타냈다.
``` python
n = 4 # 배열 길이 지정
arr = ['Pasta','Icecream','Pizza','Tomato']

# 만약 내가 위의 배열에서 'Pizza'를 얻길 원하다면, 컴퓨터에게 index 2값을 달라고 하면 됨

arr[2] # 'Pizza'
```
컴퓨터는 배열이 어디서 시작하는지 알기 때문에 배열을 읽는 속도는 굉장히 빠르다.  

따라서, 많은 자료를 읽어야 한다면 배열이 매우 효율적이다.(배열의 길이와 상관없이 인덱스에서 element를 읽어내는 속도는 같기 때문 - O(1) )

## 2.searching

데이터를 읽을 때는 그냥 값(= 'Pizza')를 얻으면 된다.  

하지만, 탐색을 할 때는 어디에 'Pizza'가 있는지 모르기 때문에(index값을 모른다는 의미)  하나하나 순차적으로 데이터 값이 'Pizza'인지 찾아야함.  
RAM을 통해 데이터값을 얻기는 쉽게 접근은 가능하다.  
그러나, 박스 안의 값을 모르는 상황이기 떄문에 배열 박스 하나씩 열어서 Pizza가 맞는지 찾아야한다.  

``` python
n = 4 # 배열 길이 지정
arr = ['Pasta','Icecream','Pizza','Tomato']

for i in range(n): # 'Pizza'를 찾을 때까지 순차 탐색
    if arr[i] == 'Pizza':
        break
```
위의 파이썬 소스코드에서의 탐색 기법을 (Linear search)선형 탐색이라 하는데,
최악의 경우 (배열의 박스에 위치하지 않는 경우) O(N)의 시간 복잡도를 갖는다.   

## 3. insert

Array에 데이터를 추가할 때의 경우는 크게 4가지 경우가 있다.  

1. 배열의 맨 뒤에 데이터 추가
2. 배열의 맨 앞에 데이터 추가
3. 배열의 중간에 데이터 추가
4. 배열의 크기를 넘어설 경우 데이터 추가할 경우 - 파이썬에는 해당 안됨  

``` python

arr = ['Pasta','Icecream','Pizza','Tomato']


# case 1

arr.insert[4,'Soup'] # arr의 마지막 위치(index = 4)에 Soup 추가 - O(1)

# case 2

arr.insert(0,'chicken') 
# 이때, index > 0에 해당하는 박스들을 모두 오른쪽으로 밀어준 후 - O(N)
# arr의 처음 위치(index = 0)에 chicken 추가

# case 3

arr.insert(2,'Potato') 
# 이때, index > 2에 해당하는 박스들을 모두 오른쪽으로 밀어준 후
# arr의 중간 위치(index = 2)에 Potato 추가

# case 4
arr.insert(12,'Mango')
# 파이썬은 배열의 크기가 넘어가는 index값에 'Mango'를 insert하면 마지막 자리에 insert된다.
# ['chicken', 'Pasta', 'Potato', 'Icecream', 'Pizza', 'Tomato', 'Soup', '1']
```

따라서, 최악의 경우 O(N)의 시간복잡도를 갖게 된다.

## 4. delete

위에 insert 섹션과 비슷하게 Array에 데이터를 제거할 때는 배열을 이리저리 움직여야한다.  


1. 배열의 맨 뒤에 데이터 제거
2. 배열의 맨 앞에 데이터 제거
3. 배열의 중간에 데이터 제거
``` python

arr = ['chicken', 'Pasta', 'Potato', 'Icecream', 'Pizza', 'Tomato', 'Soup']

# case 1

del arr[6] # arr의 마지막 위치 delete - O(1)

# case 2

del arr[0]
# arr[0]값을 제거해준 후
# index > 0에 해당하는 박스들을 모두 왼쪽으로 땡겨준다.  -O(N)


# case 3

del arr[2]
# arr[2]값을 제거해준 후
# index > 2에 해당하는 박스들을 모두 왼쪽으로 땡겨준다.

```

# 알고리즘 테스트 관점에서의 Array 및 정리

일반적인 알고리즘 문제를 풀 때는 Array(파이썬 lists)를 사용해서 풀어야 한다.
```
1. 대부분의 알고리즘 문제는 메모리 공간의 범위를 파악할 수 있도록, N 의 크기가 주어주기 때문
ex) 메모리 제한: 128M ~ 512M
2. 대부분의 얼고리즘 문제는 다수의 데이터를 효율적인 처리를 요구하기 때문 
```
배열은 데이터를 읽을 때는 정말 빠르다. (랜덤으로 접속이 가능하기 때문에)  
그러나, 검색하고, 추가하고, 삭제해야할 경우라면 속도가 느려지는 단점이 있다.  
따라서, 배열에서 추가하고, 삭제해야하는 상황이라면 배열의 맨 끝에서 작업하는 것이 효율적일 것이다.  
```
# 추가
어느 위치에서 검색,추가,삭제해도 속도가 빠른 데이터 구조(ex. deque,heap...등)와
검색이 빠른 알고리즘(ex. binary search)이 있기 때문에 배열의 단점을 보완해줄 수 있다.
```


