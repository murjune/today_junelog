# 문제: New Year Chaos
https://www.hackerrank.com/challenges/new-year-chaos/problem?isFullScreen=true&h_l=interview&playlist_slugs%5B%5D=interview-preparation-kit&playlist_slugs%5B%5D=arrays

```
만약, 이 문제가 스티커의 초기값이 1씩 증가하는 수열이 을 장담하지 않는다면, ex) stickers = [1, 2 , 4, 6 , 8]  

풀이 1의 방식으로는 풀 수 없었을 것이다. - O(N^2)의 시간복잡도를 갖게 되므로

따라서, 이 문제와 달리 stickers = [1, 2 , 4, 6 , 8] 형태로 스티커 번호를 부여하게 된다면 풀이 2와 같은 풀이로 풀어야 시간 내 문제를 해결할 수 있을 것이다.

풀이  - merge sort (분할 정복) 
```
# 풀이 - merge sort
```
swap의 총 합을 묻는 문제이고, 한 원소가 최대 2번 swap을 할 수 있다. - 2번을 넘어가게 되면 'Too chaotic'를 print해 준다.
```
``` python




import sys
input = lambda : sys.stdin.readline().rstrip()
sys.setrecursionlimit(10**6)

def merge_sort(arr):
    if len(arr) < 2:
        return arr
    mid = len(arr)//2

    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left,right)

def merge(left,right):
    global cnt
    from collections import deque
    result = []
    left = deque(left)
    right = deque(right)


    while left or right:
        if left and right:
            if left[0] > right[0]: # swap이 발생
                v= right.popleft()
                cnt += len(left) # swap한 횟수 더해주기
                result.append(v)
            elif left[0] <= right[0]:
                v = left.popleft()
                result.append(v)

        elif left and not right:
            result.append(left.popleft())
        elif not left and right:
            result.append(right.popleft())

    return result

t = int(input())
for _ in range(t):
    n = int(input()) # 10만 - 최대 O(nlogn) 알고리즘 풀이

    start = [x for x in range(1, n+1)]
    end = list(map(int, input().split()))
    cnt = 0

    for i in range(n):
        if (end[i]-1) - i > 2:
            print('Too chaotic')
            break
    else:
        merge_sort(end)
        print(cnt)




```

# 풀이 2
``` python

```
