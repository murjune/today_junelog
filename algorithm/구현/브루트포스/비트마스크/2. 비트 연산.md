참고 강의: https://www.youtube.com/watch?v=yHBYeguDR0A
# 비트 연산

비트 연산에는 4가지 연산이 있다.  
and(&), or(|), xor(^), not(~)

1. and(&). 
대응 하는 숫자가 모두 1이면 1을 반환한다.

2. or(|). 
대응 하는 숫자 중 하나라도 1이면 1 반환한다.  

3. xor(^)  
대응 하는 숫자가 서로 값이 다르면 1반환. 

4. not(~). 
1이면 0 반환, 0이면 1반환
``` python
# and : 대응 하는 숫자 모두 1일때만 1반환
print(bin(0b1001 & 0b1111)) # 0b1001

# or: 대응 하는 숫자 중 하나만 1이면 1반환
print(bin(0b1001 | 0b1111)) # 0b1111

# xor : 대응 하는 숫자가 서로 다를 때 1반환
print(bin(0b1001 ^ 0b1111)) # 0b110

# not : 0 -> 1, 1 -> 0
print(bin(~0b1001)) # -0b1010
print(~9) # -10
```
5. 시프트 연산자  
<< 는 왼쪽으로 옮긴다는 연산자, >>는 오른쪽으로 옮긴다는 연산자이다.

``` python
# << i : i만큼 왼쪽으로 옮김
print(bin(0b1 << 1)) # 0b10

# >> i : i만큼 오른쪽으로 옮김
print(bin(0b100 >> 2)) #0b1
```

# 비트의 연산 응용
1. 원소 추가
``` python
# 1. 원소 추가: i번째 수를 추가, 이미 존재하면 그대로 반환

n = 0b1101
i = 1

print(bin(n | 1 << i)) # 0b1111
```
2. 원소 제거
``` python
# 2. 원소 제거: i번째 수를 제거
n = 0b1101
i = 3

print(bin(n & ~(1<<i))) #0b101

# 풀이 과정: 0b1101 & 0b0111(= ~1 << i)
```
3. 원소 조회
``` python
# 3. 원소 조회 : i번째 수가 있나 없나?(1이면 있는 것)
n = 0b1101
i = 3
print(bin(n & (1<<i))) # 0b1000

# 풀이 과정: 0b1101 & 0b1000(= 1 << i)
```
4. 원소 토글 (0 -> 1, 1-> 0)
``` python
# 4. 원소 토글 : i번째 수가 켜져있으면 끄고, 꺼져있으면 키기
n = 0b1101
print(bin(n ^ (1<<i))) # 0b101

```


