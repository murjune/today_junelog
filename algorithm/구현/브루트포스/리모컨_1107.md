#문제: 리모컨_1107
https://www.acmicpc.net/problem/1107

# 배운점
```
생각해야하는 조건이 너무 많다면, 그냥 모든 경우의 수를 고려하자...(브루트 포스)  
너무 많은 조건을 고려하다보면 빼먹는 조건들도 많고, 시간도 오래걸리며 복잡해진다.

때론, 간단한게 가장 좋은것 같다...
```

# 오답 

``` python


# 입력
number = input() # (0 ≤ N ≤ 500,000)  # 5457

# n의 길이
m = int(input()) # 고장난 버튼
button = {0, 1, 2, 3, 4, 5 , 6, 7, 8, 9}
break_button = set(map(int, input().split()))

# 0 1 2 3 4 5 6 7 8 9

use_button = list(button - break_button) # 사용가능한 버튼

# 풀이
answer = abs(int(number)-100) # 최악의 경우: +,-버튼으로 모두 이동


# 1. numbe[i]가 사용 가능한 버튼 수 이면 계속한다.
cnt = 0

for i in number:  # number = '5457'

    if int(i) in use_button: # 사용가능한 버튼이 있을 때
        cnt += 1
        if len(number) == 1: 
            answer = min(answer, cnt) # 모두 입력할 수 있는 경우를 고려하였다.
            break
        number = number[1::] # '457'

        continue

    else: # 사용가능한 버튼이 없을 때
        for j in use_button:

            if int(i) > j :  # (i,j) = (5,3)
                tmp =  int(str(j) + str(max(use_button)) * (len(number)-1))
                # tmp = (수길이= 4) + (int('3' + '9' * (4-1)) = 3999)
                answer = min(answer,cnt + len(number)+ int(number)- tmp)

            elif int(i) < j: # (i,j) = (5,6)
                tmp = int(str(j) + str(min(use_button)) * (len(number)-1))
                # tmp = (수길이= 4) + (int('6' + '0' * (4-1)) = 6000)
                answer = min(answer,cnt + len(number)+ tmp- int(number))

print(answer)

```
## 반례:
```
입력:
99999
2
8 9

답:
7
```
## 이유
```
이동하려는 번호가 5자리일때, 그 번호로 숫자 다이얼로는 이동 못하는 경우에 다른 숫자로 갔다가 +, - 버튼으로 이동해야됩니다. 
이 때 제일 빨리 가능 경우는 5자리의 숫자로 이동하는 경우도 있지만 4,6자리에서 이동하는 경우도 있습니다.

위의 예 같은 경우에는

100,000 (6번 입력)

- (1번 입력)

총 7번 입력이다

나의 코드는 입력된 숫자와 같은 자리의 숫자들만 고려하기 때문에 문제가 일어났다.
```

# 정답

``` python

```
