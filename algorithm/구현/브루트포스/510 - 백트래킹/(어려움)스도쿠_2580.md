# 문제: 스도쿠 - (2)

https://www.acmicpc.net/problem/2580


# 풀이 :
아래 오답들은 출력이 여러개가 생기는 경우가 생겨 정답이 안된다.  

항상 재귀호출 문제는 답만 구했다고 흥분하지말고, 재귀 호출이 어떻게 끝나는지까지 보자..  

flag를 세워 recursion이 끝나도록 했다.
```

def Sudoku(start,finish):

    if start == finish:
        for i in graph:
            print(' '.join(map(str,i)))
        return True

    (i,j) = zero[start]
    candidates = inspect(i,j)
    for c in candidates:
        graph[i][j] = c
        
        if Sudoku(start+1,finish) == True: # 중요! 한개가 출력 되면 재귀호출 모두 종료!!
            return True
        graph[i][j] = 0


def inspect(x,y):
    nums = [1,2,3,4,5,6,7,8,9]
    # 세로 검사
    for i in graph[x]:
        if i in nums:
            nums.remove(i)

    # 가로 검사
    for i in range(9):
        if graph[i][y] in nums :
            nums.remove(graph[i][y])
    # 3 x 3 검사
    x, y = (x - x % 3, y - y % 3)
    for i in range(x,x+3):
        for j in range(y, y+3):
            if graph[i][j] in nums :
                nums.remove(graph[i][j])

    return nums
# 풀이
import sys
input = lambda : sys.stdin.readline().rstrip()

graph = [list(map(int,input().split())) for _ in range(9)]
zero = []
for i in range(9):
    for j in range(9):
        if graph[i][j] == 0:
            zero.append((i,j))
Sudoku(0,len(zero))

```
# 오답 1
``` python

# import sys
# input = lambda : sys.stdin.readline().rstrip()

graph = [list(map(int, input().split())) for _ in range(9)]

# 비어있는 원소 찾기
empty = []
for i in range(9):
    for j in range(9):
        if graph[i][j] == 0:
            empty.append((i,j))

# 문풀 순서
# 비어있는 원소들 순서대로 1번 함수식에 넣어서 빈칸에 넣을 숫자 후보를 뽑아낸다.
# 숫자 후보들을 그래프에 넣고 dfs를 돌린다.

# 숫자 후보 뽑기 - 빈칸에 들어갈 후보 찾는 거임

def selct(x,y):
    # 1. 가로 세로 검사
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    for i in range(9):
        if graph[x][i] in nums:  # 가로축
            nums.remove(graph[x][i])
        if graph[i][y] in nums: # 세로축
            nums.remove(graph[i][y])
    # 2. 3 X 3 검사

    # 어느 3 X 3 사각형에 위치하는지 검사
    x //= 3
    y //= 3

    for i in range(3*x, 3*(x+1)):
        for j in range(3*y, 3*(y+1)):
            if graph[i][j] in nums:
                nums.remove(graph[i][j])

    return nums

def dfs(cnt,total): # cnt: 비어 있는 원소 없앤 수 , total: len(empty)

    if cnt == total: # 비어진 원소의 개수가 없으면 종료
        return

        (x, y) = e[cnt]
        fill_nums = selct(x,y) # 채워질 숫자 후보
        for f in fill_nums: # 채울 숫자중 하나
            graph[x][y] = f
            dfs(cnt+1,total)
            graph[x][y] = 0 # 빈칸에 채워질 숫자가 아닐 경우: 되돌리기

dfs(0,len(empty))
for i in graph:
    print(' '.join(map(str,i)))

```

# 오답
문제 풀이방법을 잘못 세팅했다.. 예제만 성공하는 
```
# 반례
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
4 6 9 2 7 8 1 3 5
3 2 1 5 4 6 8 9 7
8 7 4 9 1 3 5 2 6
5 9 6 8 2 7 4 1 3
9 1 7 6 5 2 3 8 4
6 4 3 7 8 1 9 5 2
2 5 8 3 9 4 7 6 1
```
``` python


def Sudoku(zero,finish):

    if zero == finish:
        for i in graph:
            print(' '.join(map(str,i)))
        return

    for (i,j) in zero:
        if (i,j) not in finish:
            tmp = inspect(i,j)
            if tmp == False:
                continue
            else:
                graph[i][j] = tmp
                Sudoku(zero,finish+[(i,j)])
                break

def inspect(x,y):
    pivot = 45
    # 세로 검사
    tmp = 1
    for i in graph[x]:
        if i == 0:
            tmp -= 1
            if tmp < 0:
                break
    if tmp == 0:
        return pivot - sum(graph[x])

    # 가로 검사
    tmp = 1
    Sum = 0
    for i in range(9):
        Sum += graph[i][y]
        if graph[i][y] == 0:
            tmp -= 1
            if tmp < 0:
                break
    if tmp == 0:
        return pivot-Sum
    # 3 x 3 검사
    x,y = (x- x%3, y- y%3)
    Sum = 0
    tmp = 1
    for i in range(x,x+3):
        for j in range(y, y+3):
            Sum += graph[i][j]
            if graph[i][j] == 0:
                tmp -= 1
                if tmp < 0:
                    break
    if tmp == 0:
        return pivot-Sum

    return False
# 풀이
import sys
input = lambda : sys.stdin.readline().rstrip()

graph = [list(map(int,input().split())) for _ in range(9)]
zero = []
for i in range(9):
    for j in range(9):
        if graph[i][j] == 0:
            zero.append((i,j))
Sudoku(zero,[])

```
# 오답 2 - 시간초과
``` python

def Sudoku(zero,finish):

    if zero == finish:
        for i in graph:
            print(' '.join(map(str,i)))
        return

    for (i,j) in zero:
        if (i,j) not in finish:
            candidates = inspect(i,j)
            for c in candidates:
                graph[i][j] = c
                Sudoku(zero,finish+[(i,j)])
                graph[i][j] = 0


def inspect(x,y):
    nums = [1,2,3,4,5,6,7,8,9]
    # 세로 검사
    for i in graph[x]:
        if i in nums:
            nums.remove(i)

    # 가로 검사
    for i in range(9):
        if graph[i][y] in nums :
            nums.remove(graph[i][y])
    # 3 x 3 검사
    x,y = (x- x%3, y- y%3)
    for i in range(x,x+3):
        for j in range(y, y+3):
            if graph[i][j] in nums :
                nums.remove(graph[i][j])

    return nums
# 풀이
import sys
input = lambda : sys.stdin.readline().rstrip()

graph = [list(map(int,input().split())) for _ in range(9)]
zero = []
for i in range(9):
    for j in range(9):
        if graph[i][j] == 0:
            zero.append((i,j))
Sudoku(zero,[])

```
# 오답 3
``` python


def Sudoku(start,finish):

    if start == finish:
        for i in graph:
            print(' '.join(map(str,i)))
        return

    (i,j) = zero[start]
    candidates = inspect(i,j)
    for c in candidates:
        graph[i][j] = c
        Sudoku(start+1,finish)
        graph[i][j] = 0


def inspect(x,y):
    nums = [1,2,3,4,5,6,7,8,9]
    # 세로 검사
    for i in graph[x]:
        if i in nums:
            nums.remove(i)

    # 가로 검사
    for i in range(9):
        if graph[i][y] in nums :
            nums.remove(graph[i][y])
    # 3 x 3 검사
    x, y = (x - x % 3, y - y % 3)
    for i in range(x,x+3):
        for j in range(y, y+3):
            if graph[i][j] in nums :
                nums.remove(graph[i][j])

    return nums
# 풀이
import sys
input = lambda : sys.stdin.readline().rstrip()

graph = [list(map(int,input().split())) for _ in range(9)]
zero = []
for i in range(9):
    for j in range(9):
        if graph[i][j] == 0:
            zero.append((i,j))
Sudoku(0,len(zero))

```
