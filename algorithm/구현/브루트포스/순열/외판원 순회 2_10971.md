# 문제: 외판원 순회 2

다음 순열 + 브루트 포스로 푸는 문제  
도시의 노드가 0부터 시작하는 것에 유의 안해서 오래걸렸다..
# 풀이
```
모든 도시를 거쳤다가 원래 도시로 돌아와야함.
한 번 방문한 도시 다시 못옴
항상 순회할 수 있는 경우만 입력으로 주어진다.
갈 수 없는 곳 : 0 , graph[i][j] != graph[j][i]

브루트 포스로 문제를 푼다면 O(10!)
```
``` python
def I():
    I = -1
    for i in range(n-1):
        #1 A[i] <A[i+1]인 i의 최댓값 찾기
        if A[i] < A[i+1]:
            I = max(I,i)
    return I

def J(i):
    J = i+1 # i가 0이상이면 j는 무조건 존재하기 떄문

    for j in range(i+1,n):
        if A[i] < A[j]: # A[i] < A[j]를 만족하는 j의 최댓값 찾기
            J = max(J,j)
    return J


def next_permutation(A):
    i = I()

    if i == -1:  # 다음 순열이 존재하지 않을 때

        return -1
    else:
        j = J(i)
        # swap : A[i]과 A[j]을 swap
        A[i], A[j] = A[j], A[i]
        # reverse
        B = A[i + 1:]
        A = A[:i + 1] + B[::-1]
        return A


# 1.여행 경비 구하는 함수

def Expense(A):

    ans = 0
    for i in range(n):
        ans += graph[A[i]][A[i+1]]
    return ans
# 2. 순회가 가능한지 체크하는 함수
def check(A):
    A += [A[0]]
    for i in range(n):
        if graph[A[i]][A[i+1]] == 0:
            return False
    else:
        return True
# 풀이
import sys
input = lambda : sys.stdin.readline().rstrip()
n = int(input()) # (2 ≤ N ≤ 10)
A = [x for x in range(n)]

graph = [list(map(int, input().split())) for _ in range(n)]
ans = 10**7
while True:
    if A == -1: # 탐색이 완료되면 답 출력
        print(ans)
        break

    if check(A) == True: # 순회가 가능하다면 답 비교
        ans = min(ans,Expense(A))

    A.pop()


    A = next_permutation(A) # 다음 순열
```
