# 문제: 놀이공원_1561  
https://www.acmicpc.net/problem/1561

## 풀이 생각
```
1. 놀이기구의 수보다 아이들의 수가 적으면 아이들의 수를 출력한다.

2. 이분 탐색을 통해 아이들을 모두 태울 수 있는 시간(x)을 찾는다.

    1) x- 1분까지 몇 명의 아이를 태울 수 있는지 탐색합니다.
    
    2) tmp = 이분탐색함수(x) - 이분탐색함수(x-1)

    3) x분일 때, x분 % (놀이기구 탑승시간) = 0인 놀이기구를 탐색한다.
    
    4) 이때, tmp번 째 나머지가 0 인 놀이기구의 번호를 출력한다. 
    


```

# 풀이

``` python

n, m = map(int,input().split()) # n: 아이들 수 , m : 놀이기구 종류 수
# n: 20억, m: 1만, 운행시간 : 1~30
viking = list(map(int,input().split())) # 놀이기구 운행시간 배열

# 함수 1

# x분일 때 학생을 몇 명이 놀이기구를 탔는지 구한다.

def time_by_num(x,n): # x: 몇분 일때, n :  기준 학생
    if n <= m: # 놀이기구 수가 n보다 많으면 학생 수를 출력
        return n

    count = m # 0분일 때 m명
    rest = []
    arr = []
    for i in viking:
        count += x//i # x분을 i로 나눈 몫을 더해준다.
        rest.append(x % i) # x분을 i로 나눈 나머지를 rest 배열에 더해준다.

    if count == n:
        for i, k in enumerate(rest):
            if k == 0:
                arr.append(i) # 나머지가 0인 놀이기구의 index를 배열에 담는다.

        return min(arr)+1 # 나머지가 0인 놀이기구들의 번호를 return한다.

    elif count > n:
        return "more"

    else:
        return "less"

# 함수 2: 이분탐색

def binary_search(start,end):
    ans = 0
    while start <= end:
        mid = (start + end) // 2
        if time_by_num(mid,n) == "more":
            end = mid-1
        elif time_by_num(mid,n) == "less":
            start = mid +1
        else:
            ans = time_by_num(mid,n)


```
