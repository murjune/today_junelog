# Binary Search Tree(이진 탐색 트리)

이진 탐색 트리는 일종의 이진 트리 인데 다음과 같은 추가적인 조건을 성립해야 한다.  

1. 모든 노드는 왼쪽 자식의 값보다 큰 값을 갖는다.  
2. 모든 노드는 오른쪽 자식의 값도가 작은 값을 갖는다.
``` python
class Node:
    def __init__(self,data):
        # 처음 왼쪽, 오른쪽 자식이 없다고 초기화
        self.node = data
        self.left =  None
        self.right  = None

class BTS:
    def __init__(self,data):
        self.root = data
```
# insert
``` python
def insert(self,data):
    self.now_node = self.root

    while True:
        if data < self.now_node.node :
            if self.now_node.left == None:
                self.now_node.left = Node(data)
                return
            else:
                self.now_node = self.now_node.left

        elif data > self.now_node.node :
            if self.now_node.right == None:
                self.now_node.right = Node(data)
                return
            else:
                self.now_node = self.now_node.right
```
# search
```python
def search(self,data):

    # 처음 탐색할 노드는 root
    self.now_node = self.root

    while self.now_node:
        # 만약 현재 노드 값이 찾던 data라면 True를 리턴해주고 반복문 종료

        if self.now_node.node == data:
            return True
        # 만약 현재 노드의 값이 찾는 data보다 크다면 왼쪽 자식노드로 가자
        elif data < self.now_node.node:
            self.now_node = self.now_node.left
        # 만약 현재 노드의 값이 찾는 data보다 작다면 오른쪽 자식노드로 가자
        else:
            self.now_node = self.now_node.right
```
# 중간 점검
``` python
root = Node(1)
bts = BTS(root)
bts.insert(2)
bts.insert(7)
bts.insert(8)
bts.insert(6)
print(bts.search(1)) # True
print(bts.search(2)) # True
print(bts.search(3)) # False
```

# delte

잘 삭제 되었는지 확인 하기 위해 print()문을 넣었다.
``` python
    def delete(self,data):
        self.now_node = self.root
        self.parent = self.root # 삭제할 노드의 부모
        flag = False
        while self.now_node:
            # 찾는 노드가 존재 할 경우 깨기
            if self.now_node.node == data:
                flag = True
                break
            elif self.now_node.node < data:
                self.parent = self.now_node
                self.now_node = self.now_node.right
            else:
                self.parent = self.now_node
                self.now_node = self.now_node.left
        if flag == False:
            print("삭제할 노드가 트리안에 존재하지 않습니다.")
            return

        # 1. 삭제할 노드의 자식이 없을 경우
        if not self.now_node.left and not self.now_node.right:
            if data < self.parent.node:
                self.parent.left = None

            else:
                self.parent.right = None


        # 2. 삭제할 노드의 자식이 한개만 있을 경우
        # 1) 왼쪽 자식만 있는 경우
        if self.now_node.left and not self.now_node.right:
            if data < self.parent.node:
                self.parent.left = self.now_node.left
            else:
                self.parent.right = self.now_node.left
        # 2) 오른쪽 자식만 있는 경우
        elif not self.now_node.left and self.now_node.right:
            if data < self.parent.node:
                self.parent.left = self.now_node.right
            else:
                self.parent.right = self.now_node.right

        # 3. 삭제할 노드의 자식이 2개일 경우
        if self.now_node.left and self.now_node.right:

            self.change_node = self.now_node.left
            self.change_node_parent = self.now_node.left
            # 1) 삭제할 노드의 왼쪽 자식의 가장 오른쪽 줄기 녀석을 삭제할 곳에 넣을 것이다.
            while self.change_node.right:
                self.change_node_parent = self.change_node
                self.change_node = self.change_node.right

            # 2) change 노드의 왼쪽 자식이 있을 수 있는 경우 고려!
            if self.change_node.left != None:
                self.change_node_parent.right = self.change_node.left

            # 3) 이제 삭제할 녀석에 change 노드를 넣자
            if data < self.parent.node:
                self.parent.left = self.change_node
                self.change_node.left = self.now_node.left
                self.change_node.right = self.now_node.right
            else:
                self.parent.right = self.change_node
                self.change_node.left = self.now_node.left
                self.change_node.right = self.now_node.right

        print("요청하신 값을 삭제하였습니다.")
        return
```

# 최종 확인
``` python
arr = [3,8,2,4,7,9,1,6,10]
root = Node(5)
bst = BST(root)
for i in arr:
    bst.insert(i)

print(bst.search(3)) # True
print(bst.search(4)) # True
print(bst.search(1)) # True
bst.delete(6) # 요청하신 값을 삭제하였습니다.
print(bst.search(6)) # None
bst.delete(3) # 요청하신 값을 삭제하였습니다.
bst.delete(8) # 요청하신 값을 삭제하였습니다.
bst.delete(11) # 삭제할 노드가 트리안에 존재하지 않습니다.
print(bst.search(3)) # None
print(bst.search(8)) # None
```

# 전체 소스코드
``` python


class Node:
    def __init__(self,data):
        # 처음 왼쪽, 오른쪽 자식이 없다고 초기화
        self.node = data
        self.left =  None
        self.right  = None

class BST:
    def __init__(self,data):
        self.root = data

    def insert(self,data):
        self.now_node = self.root

        while True:
            if data < self.now_node.node :
                if self.now_node.left == None:
                    self.now_node.left = Node(data)
                    return
                else:
                    self.now_node = self.now_node.left

            elif data > self.now_node.node :
                if self.now_node.right == None:
                    self.now_node.right = Node(data)
                    return
                else:
                    self.now_node = self.now_node.right

    def search(self,data):

        # 처음 탐색할 노드는 root
        self.now_node = self.root

        while self.now_node:
            # 만약 현재 노드 값이 찾던 data라면 True를 리턴해주고 반복문 종료

            if self.now_node.node == data:
                return True
            # 만약 현재 노드의 값이 찾는 data보다 크다면 왼쪽 자식노드로 가자
            elif data < self.now_node.node:
                self.now_node = self.now_node.left
            # 만약 현재 노드의 값이 찾는 data보다 작다면 오른쪽 자식노드로 가자
            else:
                self.now_node = self.now_node.right

    def delete(self,data):
        self.now_node = self.root
        self.parent = self.root # 삭제할 노드의 부모
        flag = False
        while self.now_node:
            # 찾는 노드가 존재 할 경우 깨기
            if self.now_node.node == data:
                flag = True
                break
            elif self.now_node.node < data:
                self.parent = self.now_node
                self.now_node = self.now_node.right
            else:
                self.parent = self.now_node
                self.now_node = self.now_node.left
        if flag == False:
            print("삭제할 노드가 트리안에 존재하지 않습니다.")
            return

        # 1. 삭제할 노드의 자식이 없을 경우
        if not self.now_node.left and not self.now_node.right:
            if data < self.parent.node:
                self.parent.left = None

            else:
                self.parent.right = None


        # 2. 삭제할 노드의 자식이 한개만 있을 경우
        # 1) 왼쪽 자식만 있는 경우
        if self.now_node.left and not self.now_node.right:
            if data < self.parent.node:
                self.parent.left = self.now_node.left
            else:
                self.parent.right = self.now_node.left
        # 2) 오른쪽 자식만 있는 경우
        elif not self.now_node.left and self.now_node.right:
            if data < self.parent.node:
                self.parent.left = self.now_node.right
            else:
                self.parent.right = self.now_node.right

        # 3. 삭제할 노드의 자식이 2개일 경우
        if self.now_node.left and self.now_node.right:

            self.change_node = self.now_node.left
            self.change_node_parent = self.now_node.left
            # 1) 삭제할 노드의 왼쪽 자식의 가장 오른쪽 줄기 녀석을 삭제할 곳에 넣을 것이다.
            while self.change_node.right:
                self.change_node_parent = self.change_node
                self.change_node = self.change_node.right

            # 2) change 노드의 왼쪽 자식이 있을 수 있는 경우 고려!
            if self.change_node.left != None:
                self.change_node_parent.right = self.change_node.left

            # 3) 이제 삭제할 녀석에 change 노드를 넣자
            if data < self.parent.node:
                self.parent.left = self.change_node
                self.change_node.left = self.now_node.left
                self.change_node.right = self.now_node.right
            else:
                self.parent.right = self.change_node
                self.change_node.left = self.now_node.left
                self.change_node.right = self.now_node.right

        print("요청하신 값을 삭제하였습니다.")
        return


arr = [3,8,2,4,7,9,1,6,10]
root = Node(5)
bst = BST(root)
for i in arr:
    bst.insert(i)

print(bst.search(3)) # True
print(bst.search(4)) # True
print(bst.search(1)) # True
bst.delete(6) # 요청하신 값을 삭제하였습니다.
print(bst.search(6)) # None
bst.delete(3) # 요청하신 값을 삭제하였습니다.
bst.delete(8) # 요청하신 값을 삭제하였습니다.
bst.delete(11) # 삭제할 노드가 트리안에 존재하지 않습니다.
print(bst.search(3)) # None
print(bst.search(8)) # None

```
