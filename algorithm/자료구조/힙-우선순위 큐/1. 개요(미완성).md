참고 블로그: https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=leeinje66&logNo=221622360256
# Intro
힙 자료구조에 대해 알아 보기 전에, 이진 트리 자료구조 중 특별한 2가지 이진 트리에 대해서 알아 봅시다!

1. Perfect Binary Tree 
2. Complete Binart Tree 

트리의 종류 포스팅: https://github.com/murjune/today_junelog/blob/main/algorithm/%ED%8A%B8%EB%A6%AC/3.%20%ED%8A%B8%EB%A6%AC%EC%9D%98%20%EC%A2%85%EB%A5%98.md 

# Heap

힙은 일종의 Complete Binary Tree이다.  
힙은 크게 Max_Heap과 Min_Heap으로 나뉜다.
```
최대 힙: 부모 노드 값 > 자식 노드 값
최소 힙: 부모 노드 값 < 자식 노드 값
```

## 최대 힙(Max_Heap)
![image](https://user-images.githubusercontent.com/87055456/147342706-a5dfa39d-2e23-4d6a-ba56-b4e80e1aa1fd.png)

```
1. 최대 힙에서 가장 큰 값이 루트 노드에 들어가 있다.
2. N개가 Heap에 들어가 있으면 높이는 logN이다.
```
1. 최대 힙 삽입
```
1) 일단 원소(x)를 트리의 맨 마지막 위치에 추가를 해준다.  
2) 그 수와 parent를 비교하며 swap을 할지 말지 결정해 준다. (parent > x 만족해야함)
```
2. 최소 힙 제거
```
1. 맨 마지막 원소와 root에 있는 원소를 swap 해준 후, 맨 마지막 원소를 pop해준다.
2. children과 값을 비교하며 swap을 할지 말지 결정해 준다. (x > children 만족해야함)
```  

최대 힙의 삽입과 제거 연산은 O(logN)의 시간 복잡도를 갖는다.  
  -> 각 depth에서 한번씩만 비교를 해주면 되기 때문에 depth = logN -> O(logN)

## 최대 힙 구현(Heapq 모듈 사용 X)  

``` python


class Max_heap(object):
    def __init__(self):
        self.data = [None]


    def push(self,item):
        # 1. 리스트의 마지막에 item 추가
        self.data.append(item)
        idx = len(self.data) - 1 # item의 index값

        # 2. item < parent을 성립할 때까지 swap , idx는 1(root노드 인덱스)보다 커야함.
        while self.data[idx//2] >= self.data[idx] and idx > 1:

            if self.data[idx//2] < self.data[idx]:
                self.data[idx // 2], self.data[idx] = self.data[idx], self.data[idx // 2]
                idx //= 2 # 다음 단계 수행

    def remove(self):
        # 1. 리스트의 길이가 2 이상이야 한다.
        if len(self.data) < 2:
            return None
        # 2. root 노드의 값과 마지막 원소의 값을 swap
        self.data[1], self.data[-1] = self.data[1], self.data[-1]

        # 3. 마지막 원소 값 pop
        self.data.pop()
        # 4. max_Heapify - item >= children을 만족하는지 탐색

    def max_Heapify(self):
        parent = 1
        smallest = 1
        pivot = len(data)

        while True:
            left = idx * 2 # 왼쪽 자식 idx
            right = idx * 2 + 1 # 오른쪽 자식 idx
            # left와 right 모두 data 길이를 넘어가면 안됨
            if left < pivot and right < pivot:
                # 1. 왼쪽 자식 ,부모,오른쪽 자식과의 비교 -> smallest 뽑기
                if self.data[parent] > self.data[left]:
                    smallest = left
                if self.data[parent] < self.data[right]:
                    smallest = right
                    
                if smallest != parent:
                    self.data[parent], self.data[smallest] =  self.data[smallest], self.data[parent]
                    parent = smallest
                    
            else:
                break

```
