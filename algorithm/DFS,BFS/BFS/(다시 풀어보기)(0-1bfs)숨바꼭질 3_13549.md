# 문제: 숨바꼭질 3 - (1)
https://www.acmicpc.net/problem/13549. 

0-1 bfs 연습문제
참고 블로그 : https://justicehui.github.io/medium-algorithm/2018/08/30/01BFS/
# 풀이
``` python
def search_Subin(n,k):
    visted = [0] * (Max+1)
    from collections import deque
    q = deque([n])
    li = [q]
    if n > 0 and k > n:
        tmp = n * (k // n)
        tmp2 = n * ((k // n) + 1)
        q.append(tmp)
        q.append(tmp2)
        li += [tmp, tmp2]

    while q:
        v = q.popleft()
        if v == k:
            print(visted[v])
            return
        # 1. 앞으로 한 칸 이동
        if visted[v+1] == 0 and v+1 <= Max and (v+1) not in li:
            visted[v+1] = visted[v] + 1
            q.append(v+1)

            if v+1 > 0 :
                tmp = (v + 1) * (k // (v + 1))
                tmp2 = (v + 1) * (k // (v + 1) + 1)
                if visted[tmp] == 0 and visted[tmp2] == 0 and tmp not in li and tmp2 not in li:
                    visted[tmp] = visted[v] + 1
                    visted[tmp2] = visted[v] + 1
                    q.append(tmp)
                    q.append(tmp2)
        #2. 뒤로 한칸 이동
        if visted[v-1] == 0 and 0 <= v-1 and (v-1) not in li:
             visted[v-1] = visted[v] + 1
             q.append(v -1)
             if v - 1 > 0 :
                 tmp = (v - 1) * (k // (v - 1))
                 tmp2 = (v - 1) * (k // (v - 1) + 1)
                 if visted[tmp] == 0 and visted[tmp2] == 0 and tmp not in li and tmp2 not in li:
                     visted[tmp] = visted[v] + 1
                     visted[tmp2] = visted[v] + 1
                     q.append(tmp)
                     q.append(tmp2)




# 출력
import sys
input = lambda : sys.stdin.readline().rstrip()
n,k = map(int, input().split()) # (0 ≤ n,k ≤ 100,000)
Max = 100000
search_Subin(n,k)

# bfs 로 풀려했지만, 코드를 짜는 중에 쉽지 않아 고민을 하다
# 리모컨 문제와 유사한 느낌 -> 그리디+ bfs? 인듯

```
