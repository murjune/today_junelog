# 문제: 벽 부수고 이동하기4
https://www.acmicpc.net/problem/16946  


단순 BFS로만 풀면 안되는 문제..  
플러디 필 알고리즘+ BFS을 이용해야한다.
# 단 사람 풀이
``` python
from collections import deque
from sys import stdin, stdout
input = stdin.readline
print = stdout.write

n, m = map(int, input().split())
a = [list(input()) for _ in range(n)]
b = [[0]*m for _ in range(n)]
v = [0]
check = [[False]*m for _ in range(n)]
dx, dy = (-1, 0, 1, 0), (0, 1, 0, -1)

def bfs(x, y, z):
    q = deque()
    q.append((x, y))
    check[x][y] = True
    cnt = 1
    while q:
        x, y = q.popleft()
        b[x][y] = z
        for k in range(4):
            nx, ny = x+dx[k], y+dy[k]
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            if not check[nx][ny] and not a[nx][ny]:
                q.append((nx, ny))
                check[nx][ny] = True
                cnt += 1
    return cnt

def flood():
    z = 1
    for i in range(n):
        for j in range(m):
            if not a[i][j] and not check[i][j]:
                v.append(bfs(i, j, z))
                z += 1

def solve():
    for i in range(n):
        for j in range(m):
            if a[i][j]:
                s = set()
                for k in range(4):
                    ni, nj = i+dx[k], j+dy[k]
                    if 0 <= ni < n and 0 <= nj < m:
                        s.add(b[ni][nj])
                for k in s:
                    a[i][j] += v[k]
                    a[i][j] %= 10

for i in range(n):
    for j in range(m):
        if a[i][j] == '0':
            a[i][j] = 0
        else:
            a[i][j] = 1
flood()
solve()
for i in range(n):
    print(''.join(map(str, a[i])))


출처: https://rebas.kr/800 [PROJECT REBAS]
```
# 풀이

먼저 인접한 0의 그룹에 번호를 붙인 후, bfs를 돌리자

```python
# 1단계 : 0번 그룹에 번호 붙여 줘버리기~(플러드 필)
def flood(x ,y ,z):
    global zero_index
    cnt =1
    q = deque([(x, y)])
    graph[x][y] = z  # # 0번 그룹 번호 부여
    while q:
        a, b = q.popleft()

        for i, j in [(a + 1, b), (a, b + 1), (a - 1, b), (a, b - 1)]:
            if 0 <= i < n and 0 <= j < n:
                if graph[i][j] == 0:
                    graph[i][j] = z  # 인접 0번 그룹 번호 부여
                    cnt += 1
                    q.append((i, j))
    # z번 0그룹의 그룹원 수 부여
    zero_index[z] = cnt


# 자 이제 전체 탐색을 해봅시다

def bfs(i, j):
    q = deque([(i, j)])
    cnt = 1
    zero_index_visited = [0] * (z + 1)
    while q:
        a, b = q.popleft()

        for i, j in [(a + 1, b), (a, b + 1), (a - 1, b), (a, b - 1)]:
            if 0 <= i < n and 0 <= j < n:
                if graph[i][j] > 0 and zero_index_visited[graph[i][j]] == 0:
                    zero_index_visited[graph[i][j]] = 1
                    cnt += zero_index[graph[i][j]]
    return cnt % 10

# 풀이
# 입력값 (1~1000)
from collections import deque
import sys,copy
input = lambda :sys.stdin.readline().rstrip()
print = lambda x: sys.stdout.write(str(x)+ "\n")
n, m = map(int, input().split())
graph = [list(map(int, input())) for _ in range(n)]
ans = copy.deepcopy(graph)
block = []
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            graph[i][j] = -1
            block.append((i, j))

zero_index = dict()

z = 1
for i in range(n):
    for j in range(m):
        if not graph[i][j]:
            flood(i, j, z)
            z += 1

for i, j in block:
    
    ans[i][j] = bfs(i, j)

for i in ans:
    print(''.join(map(str, i)))

```

# 오답: - 시간초과  

0그룹을 중복해서 반복하게 되면
O(NM*(NM))으로 아주 넘치는 시간제한을 갖게 된다.  
``` python



def bfs(x,y):

    from collections import deque
    q = deque([(x,y)])
    Return_visited = []
    cnt = 0
    while q:
        a,b = q.popleft()

        for i, j in [(a+1,b),(a,b+1),(a-1,b),(a,b-1)]:
            if 0<=i < n and 0 <= j < m:
                if not visited[i][j] :
                    visited[i][j] = 1
                    cnt += 1
                    Return_visited.append((i,j))
                    q.append((i,j))

    # 방문 기록 돌려 주기
    for i,j in Return_visited:
        visited[i][j] = 0

    return cnt + 1 # 자기 자신도 포함

# 입력값 (1~1000)
import copy,sys
input = lambda : sys.stdin.readline().rstrip()

n,m = map(int,input().split())
graph = [list(map(int, input()))for _ in range(n)]
visited = copy.deepcopy(graph)
One = []
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            One.append((i,j))

for i,j in One:
    graph[i][j] = 0
    cnt = bfs(i,j)
    graph[i][j] = cnt%10

for i in graph:
    for j in i:
        print(j, end = '')

    print('')
```
