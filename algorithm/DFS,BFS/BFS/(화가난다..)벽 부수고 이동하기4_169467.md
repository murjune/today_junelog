# 문제: 벽 부수고 이동하기4
https://www.acmicpc.net/problem/16946  


단순 BFS로만 풀면 안되는 문제..  
플러디 필 알고리즘+ BFS을 이용해야한다.
# 풀이

먼저 인접한 0의 그룹에 번호를 붙인 후, bfs를 돌리자

```python
# 1단계 : 0번 그룹에 번호 붙여 줘버리기~(플러드 필)
def flood(x ,y ,z):
    global zero_index
    cnt =1
    q = deque([(x, y)])
    graph[x][y] = z  # # 0번 그룹 번호 부여
    while q:
        a, b = q.popleft()

        for i, j in [(a + 1, b), (a, b + 1), (a - 1, b), (a, b - 1)]:
            if 0 <= i < n and 0 <= j < n:
                if graph[i][j] == 0:
                    graph[i][j] = z  # 인접 0번 그룹 번호 부여
                    cnt += 1
                    q.append((i, j))
    # z번 0그룹의 그룹원 수 부여
    zero_index[z] = cnt


# 자 이제 전체 탐색을 해봅시다

def bfs(i, j):
    q = deque([(i, j)])
    cnt = 1
    zero_index_visited = [0] * (z + 1)
    while q:
        a, b = q.popleft()

        for i, j in [(a + 1, b), (a, b + 1), (a - 1, b), (a, b - 1)]:
            if 0 <= i < n and 0 <= j < n:
                if graph[i][j] > 0 and zero_index_visited[graph[i][j]] == 0:
                    zero_index_visited[graph[i][j]] = 1
                    cnt += zero_index[graph[i][j]]
    return cnt % 10

# 풀이
# 입력값 (1~1000)
from collections import deque
import sys,copy
input = lambda :sys.stdin.readline().rstrip()
print = lambda x: sys.stdout.write(str(x)+ "\n")
n, m = map(int, input().split())
graph = [list(map(int, input())) for _ in range(n)]
ans = copy.deepcopy(graph)
block = []
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            graph[i][j] = -1
            block.append((i, j))

zero_index = dict()

z = 1
for i in range(n):
    for j in range(m):
        if not graph[i][j]:
            flood(i, j, z)
            z += 1

for i, j in block:
    
    ans[i][j] = bfs(i, j)

for i in ans:
    print(''.join(map(str, i)))

```

# 오답: - 시간초과  

0그룹을 중복해서 반복하게 되면
O(NM*(NM))으로 아주 넘치는 시간제한을 갖게 된다.  
``` python



def bfs(x,y):

    from collections import deque
    q = deque([(x,y)])
    Return_visited = []
    cnt = 0
    while q:
        a,b = q.popleft()

        for i, j in [(a+1,b),(a,b+1),(a-1,b),(a,b-1)]:
            if 0<=i < n and 0 <= j < m:
                if not visited[i][j] :
                    visited[i][j] = 1
                    cnt += 1
                    Return_visited.append((i,j))
                    q.append((i,j))

    # 방문 기록 돌려 주기
    for i,j in Return_visited:
        visited[i][j] = 0

    return cnt + 1 # 자기 자신도 포함

# 입력값 (1~1000)
import copy,sys
input = lambda : sys.stdin.readline().rstrip()

n,m = map(int,input().split())
graph = [list(map(int, input()))for _ in range(n)]
visited = copy.deepcopy(graph)
One = []
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            One.append((i,j))

for i,j in One:
    graph[i][j] = 0
    cnt = bfs(i,j)
    graph[i][j] = cnt%10

for i in graph:
    for j in i:
        print(j, end = '')

    print('')
```
