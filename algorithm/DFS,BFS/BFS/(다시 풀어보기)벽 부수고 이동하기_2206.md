# 문제: 벽 부수고 이동하기
https://www.acmicpc.net/problem/2206

bfs로 최단 거리 구하는 문제 
```
벽을 부수고 이동할 때의 방문기록과

벽을 부수지 않고 이동할 떄의 방문기록을 따로 기록해서 풀어야한다.

``
# 풀이:
``` python

import sys
input = lambda: sys.stdin.readline().rstrip()

m,n = map(int, input().split()) # 6 4

graph = [list(input()) for _ in range(m)]
visted = [[[-1,-1] for _ in range(n)] for _ in range(m)]
visted[0][0] = [0,0]
#  (1, 1)과 (m, n)은 항상 0

def bfs():
    from collections import deque
    q = deque([(0,0,0)])

    while q:
        a,b,c = q.popleft()
        if (a,b) == (m-1,n-1):
            if -1 in visted[a][b]:
                print(max(visted[a][b])+1)
                return
            else:
                print(min(visted[a][b])+1)
                return

        for (i,j,k) in [(a+1,b,c),(a-1,b,c),(a,b+1,c),(a,b-1,c)]:
            if 0 <= i <= m-1 and 0 <= j <= n-1 : # 1. 범위
                if k == 0 and visted[i][j][0] == -1 : # k=0 and 방문 안함

                    if graph[i][j] == '0': # 벽이 없으면
                        visted[i][j][0] = visted[a][b][0] + 1
                        visted[i][j][1] = visted[a][b][0] + 1
                        q.append((i, j, k))

                    elif graph[i][j] == '1': # 벽이 있으면
                            visted[i][j][0] = visted[a][b][0] + 1
                            visted[i][j][1] = visted[a][b][0] + 1
                            q.append((i, j, k+1))

                elif k == 1 and visted[i][j][1] == -1 : # k = 1 and 방문 안함

                    if graph[i][j] == '0': # 벽이 없으면
                        visted[i][j][1] = visted[a][b][1] + 1
                        q.append((i,j,k))
    print(-1)

bfs()

```
