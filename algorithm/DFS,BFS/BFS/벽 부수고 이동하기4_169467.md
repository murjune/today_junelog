# 문제: 벽 부수고 이동하기4
https://www.acmicpc.net/problem/16946  


단순 BFS로만 풀면 안되는 문제..  
플러디 필 알고리즘+ BFS을 이용해야한다.
# 풀이

먼저 인접한 0의 그룹에 번호를 붙인 후, bfs를 돌리자

```python

```

# 오답: - 시간초과  

0그룹을 중복해서 반복하게 되면
O(NM*(NM))으로 아주 넘치는 시간제한을 갖게 된다.  
``` python



def bfs(x,y):

    from collections import deque
    q = deque([(x,y)])
    Return_visited = []
    cnt = 0
    while q:
        a,b = q.popleft()

        for i, j in [(a+1,b),(a,b+1),(a-1,b),(a,b-1)]:
            if 0<=i < n and 0 <= j < m:
                if not visited[i][j] :
                    visited[i][j] = 1
                    cnt += 1
                    Return_visited.append((i,j))
                    q.append((i,j))

    # 방문 기록 돌려 주기
    for i,j in Return_visited:
        visited[i][j] = 0

    return cnt + 1 # 자기 자신도 포함

# 입력값 (1~1000)
import copy,sys
input = lambda : sys.stdin.readline().rstrip()

n,m = map(int,input().split())
graph = [list(map(int, input()))for _ in range(n)]
visited = copy.deepcopy(graph)
One = []
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            One.append((i,j))

for i,j in One:
    graph[i][j] = 0
    cnt = bfs(i,j)
    graph[i][j] = cnt%10

for i in graph:
    for j in i:
        print(j, end = '')

    print('')
```
