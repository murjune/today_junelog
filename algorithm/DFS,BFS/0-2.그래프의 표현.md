# 인접 행렬
![image](https://user-images.githubusercontent.com/87055456/138038927-ca8c148d-4098-4440-a14c-406fe6a6a622.png)

```
정점의 개수를 v개라 하면 v X v개 크기의 이차원 배열을 이용한다.
ex) a[1][j]: (i -> j 있으면 1, i -> j 없으면 0 )


인접 행렬의 방식은 자주는 사용되지 않는다.
-> 없는 간선도 저장하기 때문에 메모리를 (O(v^2))만큼 많이 차지하기 때문이다. (주로 쉬운 문제 풀 때 사용한다.)
```
## 양방향 그래프인 경우
```
a[i][j] = a[j][i] = 1 or 0 으로 저장을 해주어야 한다.

```
## 가중치가 있는 인접 행렬

가중치(ex. 무게, 거리)가 있는 경우
```
# 1 
a[i][j] = 0(가중치가 없는 경우) 와 w(가중치) 로 경우를 나눈다.

# 2 - (w >= 0)인 경우
a[i][j] = -1(가중치가 없는 경우) 와 w(가중치) 로 경우를 나눈다.

# 3 - (w가 정수 전체)인 경우

1) a[i][j] = INF(무한수, 약 10억)(가중치가 없는 경우) 와 w(가중치) 로 경우를 나눈다.
2) a[i][j] = (0,0)(가중치가없음), (1,w) (가중치가 있고, 가중치가 w)인 경우로 나눌 수 있다. 


```
예시
``` python
# 노드: 0, 1, 2 # 간선: 0-1(거리: 7) , 0-2(거리: 5)

# 인접 행렬 방식 예제

INF = 999999999 # 무한의 비용 선언 (약 10억)

# 2차원 리스트를 이용해 인접 행렬 표현

# 각 노드 사이의 거리를 나타내는 graph
graph = [
    [0,7,5],
    [7,0,INF],
    [5,INF,0]
]
print(graph) # [[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
```
# 인접 리스트 *** (매우 중요, 주로 이 방식을 사용한다. )
![image](https://user-images.githubusercontent.com/87055456/138040807-65cf16b2-8a39-4668-be24-945d0711f430.png)

보통 linked 리스트를 사용한다.( 파이썬에서는 이미 리시트 들이 연결되었으므로 따로 불러올 필요 없다. )
```

a[i]는 i와 연결된 정점을 표현하고 있다. (즉, a[i]는 정점이 아니라 i와 a[i]와 연결된 간선을 뜻한다)


간선이 정점에 비해 개수가 매우 적으면, 인접 행렬 보다 '인접리스트' 방식이 훨씬 효율적이다.
cf) 반대로 간선의 개수가 많다면 '인접 행렬'이 더 유리

인접 리스트의 공간 복잡도 = O(E)이다. (양방향의 경우 2 x E , 2는 생략)
cf) 인접 행렬의 공간 복잡도 = O(v^2)

하지만, linke 리스트는 구현하는데 오래 걸리기 떄문에 속도가 느리다. 

```
## 가중치가 있는 인접 리스트
![image](https://user-images.githubusercontent.com/87055456/138041629-a4500950-8cf5-4667-ae3a-4ca57937f35f.png)

```
ex) 가중치: 거리 
a[i] = [(1,2), (2,3)]

i - 1 이 2의 거리로 연결
i - 2 가 3의 거리로 연결 
```
예시

``` python
# 노드: 0, 1, 2 # 간선: 0-1(거리: 7) , 0-2(거리: 5)

# 인접 리스트 방식 예제

graph = [[]for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)

graph[0].append((1,7))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)

graph[1].append((1,7))
graph[1].append((2,5))
# 노드 2에 연결된 노드 정보 저장(노드, 거리)

graph[2].append((0,5))

print(graph) # [[(1, 7)], [(1, 7), (2, 5)], [(0, 5)]]

```
# 결론- 인접행렬과 인접리스트 방식의 차이

```
1. 메모리 측면
인접행렬: 모든 관계를 저장하기 때문에 노드의 개수가 많을 수록 메모리가 불필요하게 낭비된다.
인접리스트: 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다. 
         하지만, 이런 속성 때문에 인접리스트 방식은 상대적으로 특정한 노드가 연결 되어 있는지에 대한 정보를 얻는 속도가 느리다.
         인접리스트 방식에서는 연결된 데이터를 하나씩 확인해야 하기 때문이다.
예시)
graph의 노드 1과 노드 7이 연결되었다고 생각해보자.

인접 행렬 방식: graph[1][7]만 확인하면 된다.
인접 리스트 방식: 노드 1에 대한 인접리스트의 앞부터 순차적으로 확인한다.
# 공간 복잡도 비교
1) 인접 행렬 : O(V^2)
2) 인접 리스트: O(E)
# 정리
1) "" 특정한 노드 ""와 연결된 모든 인접 노드를 순회해야 하는 경우라면
인접 리스트 방식이 인접행렬 방식에 대해 메모리 공간의 낭비가 적다.

2)모든 노드의 연결된 인접 노드를 순회해야하는 경우라면 인접 행렬방식이 낫다.

그러나, 우리가 푸는 문제들의 대부분 노드에 비해 간선의 개수가 현저히 적기 때문에 '인접 리스트' 방식을 자주 사용한다.
```
