# 문제: 평범한 배낭
https://www.acmicpc.net/problem/12865

냅색이론 연습 문제 - 아래 블로그에서 풀이를 참고하였다.  
이코테의 효율적인 화폐구성 문제: https://github.com/murjune/today_junelog/blob/main/algorithm/dp/%EC%9D%B4%EC%BD%94%ED%85%8C/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%20%ED%99%94%ED%8F%90%EA%B5%AC%EC%84%B1.md  
의 응용 버전이다.  

# 풀이
![image](https://user-images.githubusercontent.com/87055456/141985258-a003bf0d-fc34-4f4b-9a22-daad9b460a84.png)
출처: https://claude-u.tistory.com/208
``` python

# 입력값 1: n(1~100), k(1~10만)
# 입력값 2: n 개의 물건의 w, k 값 배열 (w: 1~10만, v: 0~1000)

n, k = map(int,input().split()) # 4,7
arr = [[0,0]]+[list(map(int,input().split())) for _ in range(n)]
d = [[0 for _ in range(k+1)]for _ in range(n+1)]

# 풀이
# 정렬(무게순)
arr = sorted(arr, key= lambda x: x[0])
# arr = [[0, 0], [3, 6], [4, 8], [5, 12], [6, 13]]

for i in range(1,n+1): # 물건
    w = arr[i][0]
    v = arr[i][1]
    for j in range(w,k+1): # 무게
        # 만약 w가 k 보다 커지면 반복문이 진행 안됨

        if j< w: # 물건 무게 > 현재 무게
            d[i][j] = d[i-1][j]
        else: # 물건 무게 < 현재 무게
            tmp = d[i-1][j-w] + v #  d(현재 무게 - 물건 무게) + 현재 물건 가치
            d[i][j] = max(d[i-1][j], tmp)

print(d[n][k])
```
