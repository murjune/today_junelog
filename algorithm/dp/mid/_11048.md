# 문제: [이동하기](https://www.acmicpc.net/problem/11048)  

# 풀이  
바텀-업 방식으로 dp알고리즘 풀이  
```python

import sys
input = lambda : sys.stdin.readline().rstrip()
n,m = map(int,input().split())
candies = [list(map(int,input().split())) for _ in range(n)]
d = [[0]*(m+1) for _ in range(n+1)]

for i in range(1,n+1):
    for j in range(1,m+1):
        # 점화식
        d[i][j] = candies[i-1][j-1]+max(d[i-1][j],d[i][j-1], d[i-1][j-1])

print(d[n][m])

```  

# 틀린 풀이 - 90%에서 시간초과  

탑-다운식 재귀함수를 통해 dp 알고리즘을 구현해봤는데 파이썬으로는 안되는 것 같다..  
그냥 반복문을 사용해서 풀자
```python
import sys
sys.setrecursionlimit(10**6)
input = lambda : sys.stdin.readline().rstrip()
n,m = map(int,input().split())
candies = [list(map(int,input().split())) for _ in range(n)]
d = [[0]*m for _ in range(n)]

def dp(x,y):

    if x < 0 or x > n-1 or y < 0 or y > m-1: return 0
    if d[x][y]: return d[x][y]
    # 점화식
    d[x][y] = candies[x][y]+max(dp(x-1,y),dp(x,y-1),dp(x-1,y-1))
    return d[x][y]

print(dp(n-1,m-1))


```  
