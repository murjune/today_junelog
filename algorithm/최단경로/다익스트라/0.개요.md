# 다익스트라 최단 경로 알고리즘

다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 한 노드에서 출발하여 다른 노드로 가는 각각의 최단경로를 구해주는 알고리즘이다.  

다익스트라 알고리즘은 '음의 간선'이 없을 경우, 정상적으로 작동한다.  
따라서, 현실세계에서 GPS 소프트웨어의 기본 알고리즘으로 채택 되곤 한다.  

다익스트라 최단 경로 알고리즘은 기본적으로 그리디 알고리즘으로 분류 된다.  
그 이유는 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복 하기 때문이다.  

# 다익스트라 원리 
```
1. 출발 노드를 설정 한다. (start)
2. 최단 거리 테이블을 INF값으로 초기화 시킨다.
3. 방문 하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택한다. 
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 기존 저장 되어있는 비용과 비교하여 최단 거리 테이블을 갱신해준다.  

5. 3,4번 과정을 계속 반복해준다. -> 3,4번을 한단계라고 했을 때, 한단계당 하나의 노드에 대한 최단거리를 확실히 찾읗 수 있다.

```



# 간단한 다익스트라 알고리즘 소스코드 - 시간 복잡도(O(V^2)). 

느리게 동작하긴 하지만, 구현하기 간단하기 때문에 이해를 위해 O(V^2)의 시간복잡도를 갖는 다익스트라 알고리즘을 작성하겠다.  

1단계 (위의 3,4과정)를 진행할 때마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다  
1차원 리스트의 모든 원소를 확인(순차탐색)하기 때문에 O(V^2)의 시간 복잡도를 갖게 된다.

-> 정리: O(V)번에 걸쳐서 최단 거리가 가자 짧은 노드를 선형 탐색해야 하고, 현재 노드와 연결된 노드를 일일이 확인하기 때문에 O(V^2의 시간 복잡도를 갖는다

따라서, 노드의 개수가 10000개를 넘어가는 문제에서는 이코드로 문제 해결이 힘들다. -> 개선된 다익스트라 알고리즘의 탄생   

다음 페이지에 개선된 다익스트라 알고리즘에 대해 작성하겠다.
```
입력값:
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2

출력값:
0
2
3
1
2
4

```
``` python
# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    idx = 0 # 가장 최단 거리가 짧은 노드의 index
    
    for i in range(1,n+1):
        if not visited[i] and distance[i] < min_value:
            min_value = distance[i]
            idx = i
    return idx

# 다익스트라 

def dijkstra(start):
    # 시작 노드에 대해 초기화
    distance[start] = 0
    visited[start] = True
    
    for j in graph[start]:
        distance[j[0]] = j[1]
    
    # 시작 노드를 제외한 전체 n-1개의 노드에 대해 반복
    
    for i in range(n-1):
        # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visited[now] = True
        
        # 현재 노드와 연결된 다른 노드를 확인
        
        for j in graph[now]:
            cost = distance[now] + j[1]
            
            # 현재 노드를 거쳐서 다른 노드로 이동하느 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost

import sys
input =lambda : sys.stdin.readline().rstrip()
INF = int(1e9) # 무한을 의미하는 값으로 10억 설정 - int값을 꼭 씌워줘야함

# 노드 개수, 간선의 개수
n, v =map(int,input().split())
# 시작 노드 번호로 입력 받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 graph
graph = [[]for i in range(n+1)]
# 방문 기록 list
visited = [False]* (n+1)
# 최단 거리 테이블: 모두 INF으로 초기화
distance = [INF]*(n+1)

# 모든 간선 정보를 입력 받기

for _ in range(v):
    a, b, c = map(int,input().split())
    # a노드 -> b노드 가는 가중치 c
    graph[a].append((b, c))

# 다익슽트라 알고리즘 수행

dijkstra(start)

# 모든 노드로 가기 위한 최단 거리 출력

for i in range(1,n+1):
    # 도달할 수 없는 경우 -1 출력
    if distance[i] == INF:
        print(-1)
    # 도달할 수 없는 경우 거리 출력
    else:
        print(distance[i])
 ```
