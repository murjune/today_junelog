# 문제: 트리의 지름
https://www.acmicpc.net/problem/1167


# 풀이- 오답

``` python


# 트리의 부모 찾기 -(dfs풀이)
import sys
sys.setrecursionlimit(10**6)
input = lambda : sys.stdin.readline().rstrip()

# root: 1
# 입력
n = int(input())
graph = [[]for _ in range(n+1)]

# 트리 그래프 저장
for _ in range(n):
    tmp = list(map(int, input().split()))
    for i in range(1,20000,2):
        if tmp[i] == -1:
            break
        graph[tmp[0]].append((tmp[i],tmp[i+1]))

visted1 = [False,True]+ [False]*(n-1)
# [[], [(3, 2)], [(4, 4)], [(1, 2), (4, 3)], [(2, 4), (3, 3), (5, 6)], [(4, 6)]]

# 탐색 함수
ans = 0
def dfs_search(x,cnt,arr):

    for i in graph[x]:
        if arr[i[0]] == False: # 방문한적 없으면
            arr[i[0]] = cnt + i[1]
            dfs_search(i[0],cnt+i[1],arr)


dfs_search(1,0,visted1)
tmp = 0
for i,k in enumerate(visted1):
    if k == max(visted1):
        tmp = i
        break

visted2 = [False]*(n+1)
visted2[tmp] = True

dfs_search(tmp,0,visted2)
result = max(max(visted1),max(visted2))

print(result)


```

# 정답 - dfs 풀이
위의 소스코드 중 시간 초과된 부분이다.
``` python
for i,k in enumerate(visted1): # enumerate * max = O(N^2)이다.
    if k == max(visted1):
        tmp = i
        break
```
max/min : O(N), for i in a : O(N) -> O(N^2) 이다....
따라서, 이 부분을 아래와 같이 바꿨다
``` python
tmp = visted1.index(max(visted1)) # index()의 시간 복잡도는 O(1)이다.
```
아래와 같이 max()를 for문 밖으로 빼놔도 O(N)이므로 가능! 
``` python
a = max(visted1)
for i,k in enumerate(visted1):
    if k == a:
        tmp = i
        break
```
# 전체 풀이 소스코드
``` python
# 트리의 부모 찾기 -(dfs풀이)
import sys
sys.setrecursionlimit(10**6)
input = lambda : sys.stdin.readline().rstrip()

# root: 1
# 입력
n = int(input())
graph = [[]for _ in range(n+1)]

# 트리 그래프 저장
for _ in range(n):
    tmp = list(map(int, input().split()))
    for i in range(1,len(tmp)-1,2):
        if tmp[i] == -1:
            break
        graph[tmp[0]].append((tmp[i],tmp[i+1]))

visted1 = [False,True]+ [False]*(n-1)
# [[], [(3, 2)], [(4, 4)], [(1, 2), (4, 3)], [(2, 4), (3, 3), (5, 6)], [(4, 6)]]

# 탐색 함수
ans = 0
def dfs_search(x,dist,vist):

    for n, d in graph[x]:
        if vist[n] == False: # 방문한적 없으면
            vist[n] = dist + d # 거리 정보 저장
            dfs_search(n,dist+d,vist)


# 첫 번째 탐색
dfs_search(1,0,visted1)
tmp = visted1.index(max(visted1))

# 두 번째 탐색
visted2 = [False]*(n+1)
visted2[tmp] = True

dfs_search(tmp,0,visted2)
# 출력
result = max(visted2)

print(result)



```
