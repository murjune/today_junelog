# 상수 형태의 문자열을 가르키는 포인터 - 자세한 내용 (열혈C 303p)

다음과 같이 선언 되는 문자열은 상수 형태의 문자열이다.
```c
char * str = "const str";
```
이 문장이 실행되면 먼저 문자열이 메모리공간에 저장된 후, 그 메모리의 주소 값을 반환한다.  
즉 문자열이 0x1234번지에 저장되었다고 가정하면, 위 문장에서 문자열이 저장된 이후의 형태는 다음과 같다.  
```c
char * str = 0x1234;
```
## 문자열 출력
```c
char* str = "string";
printf(str); 
```
" "로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소값을 반환한다.  
따라서, 위의 함수 호출 문장(printf())도 메모리 공간에 문자열이 저장된 이후의 다음 형태가 된다.
```c
printf("0x1234"); // 0x1234번지에 저장되었다고 가정
```
이렇듯 printf함수는 문자열을 통째로 전달받는 함수가 아닌, **문자열의 주소값을 전달받는 함수!!!**이다.  

따라서, 다음의 함수 호출문을 보면
```c
Function("Hello"); // function이라는 이름의 함수 호출
```
실제로 전달되는 값은 문자 'H'의 **주소 값**이다.
```c
void Function(char * str) // 주소값을 전달받는다.
{
	....
}
```
# 포인터 배열
```C
# include <stdio.h>


// 전역 변수
char* arr[5] = {"ac","ac","ac","ac"}; 

int main(void)
{	
	int* ptr = arr[1]; // ptr arr[1]에 위치하는 주소값을 가르킴
	
	printf("%c\n",ptr[1][0]); // ptr[1] -> "ac"가르킴, ptr[1][0] -> "ac"에서의 'c'를 가르킴
	 
	printf("%s\n",arr[1]); 
	printf("%s\n",arr[3]);
	return 0;
 } 

```
위 예제의 문자열 배열 또한
```c
char* arr[5] = {"ac","ac","ac","ac"}; 
```
위 문장이 수행되면(문자열이 저장되면) 다음과 같은 형태가 된다.
```c
char* arr[5] = {0x1..,0x2..,0x3..,0x4..}; 
```
그런데 반환된 주소 값은 문자열의 첫 번째 문자의 주소 값이니, 이렇듯 char형 포인터 배열에 저장이 가능하게 되는 것이다!!
