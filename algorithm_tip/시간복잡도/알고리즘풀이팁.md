# 복잡도(Complexity)

``` 
복잡도는 알고리즘의 성능을 나타내는 척도이다.

1) 시간 복잡도: 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
2) 공간 복잡도: 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석

동일한 기능을 수행하는 알고리즘이 있다면, 일반적으로 복잡도가 낮을수록 좋은 알고리즘이다.
```
# 빅오 표기법(Big-O Notation)
![image](https://user-images.githubusercontent.com/87055456/134326524-690bc6f8-7052-4973-92c4-c428d8fae8bf.png)

극한의 개념으로 생각하면 편하다.
```
가장 빠르게 증가하는 항만을 고려하는 표기법이다.
  함수의 상한만을 나타내게 된다.

ex) 연산 횟수가 3N^3 + 5N^2 + 1,000,000인 알고리즘이 있다고 하자.
이때 빅오 표기법에서는 차수가 가장 큰 항만을 남기므로 O(N^3)으로 표현한다.

```
# 시간 복잡도 계산해보기

## 예시 1

``` python
# N개의 데이터 합을 계산하는 프로그램 예제

arr =[3, 5, 1, 2, 4] # 5개의 데이터(N = 5)
sum = 0 # 합계를 저장할 변수

# 모든 데이터를 하나씩 확인하며 합계를 계산

for x in arr:
  sum += x

# 결과
print(sum)

# 수행 시간은 데이터의 개수 N에 비례할 것임을 예측핧 수 있다.
# 시간 복잡도: O(N)

```

## 예시 2


``` python
# N개의 데이터 합을 계산하는 프로그램 예제

arr =[3, 5, 1, 2, 4] # 5개의 데이터(N = 5)
sum = 0 # 합계를 저장할 변수


for i in arr:
  for j in arr:
    tmp = i * j
    print(tmp)

# 시간 복잡도: O(N^2)
# 참고로 모든 2중 반복문의 시간 복잡도가 O(N^2)인 것은 아니다.
  # 소스코드가 내부적으로 다른 함수를 호출한다면 그 함수의 시간 복잡도까지 계산해야한다!!

```
# 알고리즘 설계 Tip
![image](https://user-images.githubusercontent.com/87055456/134327661-ce4bb985-3c24-40b4-97c8-b2bf809dec82.png)

# 요구사항에 따라 적절한 알고리즘 설계하기

![image](https://user-images.githubusercontent.com/87055456/134327953-c8161db4-325b-4de3-9103-7689abfb26eb.png)

# 알고리즘 문제 해결 과정
![image](https://user-images.githubusercontent.com/87055456/134329091-92fc6e72-58a1-4830-920f-6c3462976fbf.png)

