참고: https://wikidocs.net/21638

# 소수 구하기 1

1부터 100 사이의 소수를 구하는 파이썬 코드 - 시간 복잡도O(N^2)
``` python
n=100

def isPrime(a): # 소수인지 검사하는 함수(isPrime)
  if(a<2):
    return False
  for i in range(2,a):
    if(a%i==0):
      return False
  return True

for i in range(n+1):
  if(isPrime(i)):
    print(i)
```
위의 코드는 해당 수보다 작은 모든 수로 나누어 보아서 소수인지를 판단하는 방법으로, 소수의 정의에 충실한 방법이면서 무식하지만 가장 강력한 방법이다.  
한 개의 소수를 구할 때는 그런대로 괜찮은 방법인데 범위의 모든 소수를 구할 때는 효율적인 방법이 아니다.  
소수를 구하기 위해 에라토스테네스가 제안한 방법은 다음과 같다.
# 소수 구하기 2
자연수의 약수가 가지는 특성을 이용해서, 시간 복잡도를 O(N**1/2)까지 줄일 수 있다.  
자연수 n은 가운데 약수를 기준으로, 2개씩 앞뒤로 묶어서 곱하면 n을 만들 수 있다.  
```
ex) n = 16

1, 2, 4, 8 ,16

1 x 16 =16
2 x 8 = 16
4 x 4 = 16
```
위의 예시는 따라서, 2, 4만 확인하면 n이 소수인지 아닌지 판단할 수 있다.  
즉, 제곱근(가운데 약수)까지만 확인하면 소수 판별을 할 수 있다.
```python
n = int(input())

def is_Prime(x):

    for i in range(2,int(x**1/2)+1):
        if x % i == 0 :
            return False

    return True

print(is_Prime(n))
```
# 에라토스테네스의 체- 시간 복잡도-약 O(N) = O(NloglogN)

에라토스테네스의 체 : 범위에서 합성수를 지우는 방식으로 소수를 찾는 방법.  
![image](https://user-images.githubusercontent.com/87055456/144377645-facf81d1-209e-4036-8d36-cd23335cedc6.png)

에라토스테네스의 체는 N보다 작거나 같은 모든 소수를 찾는 즉, 전체 수 범위 안에서 존재하는 모든 소수를 찾아야하는 경우에 쓰인다.  

# 에라토스 테네스의 단점
에라토스테네스의 체 알고리즘은 매우 빠르게 동작하기 때문에 다수의 소수를 찾아야하는 문제에서 자주 사용된다.  
그러나, 메모리가 많이 필요하다는 단점이 있는데, 예를 들어 N=1000만 일 경우, 2~1000만까지의 모든 수에 대한 정보를  
담을 수 있는 리스트가 필요하다. 또한, 10억이 소수인지 찾아야하는 문제 같은 경우는 에라토스테네스의 체를 사용할 수 없다.  

따라서, 에라토스테네스의 체를 이용해야하는 경우는 N이 100만이내의 범위로 주어지는 경우일 때이다.  
N이 100만일 때, 이론상 400만 정도의 연산으로 문제 해결 가능하다.
# 에라토스테네스 체의 과정
```
# 방법
0. 2~ N까지 자연수 나열
1. 1은 제거 
2. 지워지지 않은 수 중 제일 작은 2를 소수로 채택하고, 나머지 2의 배수를 모두 지운다. 
3. 지워지지 않은 수 중 제일 작은 3을 소수로 채택하고, 나머지 3의 배수를 모두 지운다. 
4. 지워지지 않은 수 중 제일 작은 5를 소수로 채택하고, 나머지 5의 배수를 모두 지운다. 
5. (반복)
```
## 에라토스테네스의 체 파이썬 소스코드
``` python



# 에라토스테네스의 체
n = 100

check = [False] *(n+1)
primes = []
# 1. 0과 1을 지우고
check[0] =True
check[1] = True

# 2. 2부터 배수를 지운다

for i in range(2,n+1):
    if check[i] == False: # i가 지워지지 않은 수 일 때
        primes.append(i) # i는 소수다!

        for j in range(i**2,n+1,i): # i의 배수를 모두 지우자
            check[j] = True # 배수 지우기


print(primes)
```
```python
n = int(input())

check = [True] *(n+1)

# 1. 0과 1을 지우고
check[0] = False
check[1] = False

for i in range(2,int(n**1/2)+1):
    if check[i] == True: # i가 소수면

        for j in range(i*i,n+1,i): # i의 배수는 모두 소수가 아니다.
             check[j] = False

for i in range(2,n+1):
    if check[i]:
        print(i,end=' ')
```

